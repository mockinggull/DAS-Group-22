---
title: "The Influence of Text Characteristics for Email Classification"
author: "Group 22"
number-sections: true
format: 
  html:
    embed-resources: true
    code-tools: true
  pdf: default
editor_options: 
  chunk_output_type: console
execute:
  echo: true
  eval: true
  warning: false
  message: false
---

```{r}
#| label: libraries
library(tibble)
library(ggplot2)
library(dplyr)
library(gt)
library(patchwork)
library(gridExtra)
library(broom)
library(knitr)
library(GGally)
library(sjPlot)
library(MASS)
```

```{r}
#| label: read data
email<-read.csv("dataset22.csv")
```

```{r}
#| label: convert cht to factor
email$yesno<-as.factor(email$yesno)
```

## Introduction

This analysis focuses on identifying the characteristics of email messages that are predictive of spam. With the rise of unwanted and potentially harmful emails, effective spam detection has become a crucial challenge. By analysing patterns in email content, structure, and metadata, we aim to identify the distinguishing features that separate spam from legitimate messages. Gaining a deeper understanding of these characteristics can lead to the development of smarter, more accurate filtering systems that reduce inbox clutter and protect users from scams and other malicious activities.

## Exploratory Data Analysis {#sec-EDA}

### Data Visualization

```{r}
#| label: fig-pairs
#| fig-cap: Correlations between each variables.
ggpairs(email[,1:6]) +
  theme(plot.background = element_rect(
    fill = "transparent",
    colour = NA,
    size = 1))
```

By @fig-pairs, we see that the correlations between each explanatory is not larger than 0.4, which means the relationship between each variable is weak. It suggests that there is not much concern about multicollinearity. From the scatter plot, there are some points are far away from cluster. Those points can be removed as outliers to improve model's stability.

### Removing Outliers

```{r}
#| label: Remove Outliers by z score
remove_outliers_rowwise_zscore <- function(df) {
  df_clean <- df
  for (col_name in names(df)) {
    if (is.numeric(df[[col_name]])) {
      z_scores <- scale(df[[col_name]])
      df_clean <- df_clean[abs(z_scores) <= 3, ]
    }
  }
  return(na.omit(df_clean))
}
email_clean <- remove_outliers_rowwise_zscore(email)
```

To minimize outliers while preserving as much information as possible, z score are used to remove outliers.

### Scaling Data

```{r}
#| label: tbl-range
#| tbl-cap: Range of each variables.
range_table <- apply(email_clean[-7], 2, range)
range_df <- as.data.frame(t(range_table))
colnames(range_df) <- c("Min", "Max")
range_df$Variables<-colnames(email_clean[-7])
gt(range_df[,c(3,1,2)])
```

After removing outliers, the @tbl-range shows the range of each variable. It is clear that the range of the number of total length of uninterrupted sequences of capitals is extremely large than others. Hence, normalization are processed to reduce bias when large scale may dominates the cost function.

```{r}
#| label: tbl-scaled_range
#| tbl-cap: Range of each scaled variables.
email_clean$crl.tot<-scale(email_clean$crl.tot)
range_table <- apply(email_clean[-7], 2, range)
range_df <- as.data.frame(t(range_table))
colnames(range_df) <- c("Min", "Max")
range_df$Variables<-colnames(email_clean[-7])
gt(range_df[, c(3,1,2)]) %>%
  fmt_number(columns = everything(),decimals = 2)
```

After scalingï¼Œthe range of the number of total length of uninterrupted sequences of capitals is shrank to a range which is close to others. 

### Data Visualization

```{r}
#| label: fig-boxplot.crl.tot
#| fig-cap: Boxplot of total length of uninterrupted sequences of capitals.
ggplot(email_clean, aes(x = yesno, y = crl.tot)) +
  geom_boxplot() +
  labs(x = "Spam indictor", y = "Uninterrupted sequences of capitals", 
       title = "Spam indictor with total length of uninterrupted sequences of capitals")
```

```{r}
#| label: fig-boxplot.dollar
#| fig-cap: Boxplot of occurrences of the dollar sign.
ggplot(email_clean, aes(x = yesno, y = dollar)) +
  geom_boxplot() +
  labs(x = "Spam indictor", y = "Occurrences of the dollar sign", 
       title = "Spam indictor with occurrences of the dollar sign")
```

```{r}
#| label: fig-boxplot.bang
#| fig-cap: Boxplot of occurrences of '!'.
ggplot(email_clean, aes(x = yesno, y = bang)) +
  geom_boxplot() +
  labs(x = "Spam indictor", y = 'Occurrences of "!"', 
       title = 'Spam indictor with occurrences of "!"')
```

```{r}
#| label: fig-boxplot.money
#| fig-cap: Boxplot of occurrences of "money".
ggplot(email_clean, aes(x = yesno, y = money)) +
  geom_boxplot() +
  labs(x = "Spam indictor", y = 'Occurrences of "money"', 
       title = 'Spam indictor with occurrences of "money"')
```

```{r}
#| label: fig-boxplot.n000
#| fig-cap: Boxplot of occurrences of '000'.
ggplot(email_clean, aes(x = yesno, y = n000)) +
  geom_boxplot() +
  labs(x = "Spam indictor", y = 'Occurrences of "000"', 
       title = 'Spam indictor with occurrences of "000"')
```

```{r}
#| label: fig-boxplot.make
#| fig-cap: Boxplot of occurrences of 'make'.
ggplot(email_clean, aes(x = yesno, y = make)) +
  geom_boxplot() +
  labs(x = "Spam indictor", y = 'Occurrences of "make"', 
       title = 'Spam indictor with occurrences of "make"')
```

## Formal Data Analysis

### Fitting Model in Log-odds

```{r}
#| label: fiting model1
model1 <- glm(yesno ~ crl.tot+dollar+bang+money+n000+make, data = email_clean, 
             family = binomial(link = "logit"))
```

```{r}
#| label: summary model1
#| tbl-cap: Summary of model1.
library(jtools)
summary(model1)
mod1coefs <- round(coef(model1), 2)
```

\begin{align}
\ln\left(\frac{p}{1-p}\right) &= \alpha + \beta_{crl.tot} \cdot \textrm{crl.tot} +\beta_{dollar} \cdot \textrm{dollar} +\beta_{bang} \cdot \textrm{bang} +\nonumber\\&\hspace{0.5cm}\beta_{money} \cdot \textrm{money} +\beta_{n000} \cdot \textrm{n000}+\beta_{make} \cdot \textrm{make} \nonumber\\&= `r mod1coefs[1]` + `r mod1coefs[2]` \cdot \textrm{crl.tot} +`r mod1coefs[3]` \cdot \textrm{dollar} +`r mod1coefs[4]` \cdot \textrm{bang} +`r mod1coefs[5]` \cdot \textrm{money} +`r mod1coefs[6]`\cdot \textrm{n000}+`r mod1coefs[7]`\cdot \textrm{make} \nonumber
\end{align}

```{r}
#| label: fiting model2
model2 <- glm(yesno ~ crl.tot+dollar+bang+money+n000, data = email_clean, 
             family = binomial(link = "logit"))
```

```{r}
#| label: summary model2
#| tbl-cap: Summary of model2.
summary(model2)
mod2coefs <- round(coef(model2), 3)
```

```{r}
#| label: Find out the baseline category.
levels(email$yesno)
```

\begin{align}
\ln\left(\frac{p}{1-p}\right) &= \alpha + \beta_{crl.tot} \cdot \textrm{crl.tot} +\beta_{dollar} \cdot \textrm{dollar} +\beta_{bang} \cdot \textrm{bang} +\nonumber\\&\hspace{0.5cm}\beta_{money} \cdot \textrm{money} +\beta_{n000} \cdot \textrm{n000} \nonumber\\&= `r mod2coefs[1]` + `r mod2coefs[2]` \cdot \textrm{crl.tot} +`r mod2coefs[3]` \cdot \textrm{dollar} +`r mod2coefs[4]` \cdot \textrm{bang} +`r mod2coefs[5]` \cdot \textrm{money} +`r mod2coefs[6]`\cdot \textrm{n000} \nonumber
\end{align}

```{r}
#| label: summary_confident_of_model2_coefficient
#| tbl-cap: Summary confident of model2 coefficient.
confint(model2) %>%
  kable()
```

```{r}
#| label: fig-CI-of-Log-odds
#| fig-cap: 95% CI of confidents in Log-odds.
plot_model(model2, show.values = TRUE, transform = NULL,
           title = "Log-Odds (Email indicator)", show.p = TRUE)
```

### Variable Selection

```{r}
#| label: p_value_Comparation
#| tbl-cap: p value Comparation.
p_values1 <- summary(model1)$coefficients[, "Pr(>|z|)"]
p_values2 <- summary(model2)$coefficients[, "Pr(>|z|)"]

# Create data frames for each model
results1 <- data.frame(Variable = names(p_values1), P_Value_Model1 = p_values1)
results2 <- data.frame(Variable = names(p_values2), P_Value_Model2 = p_values2)

# Merge results by Variable (outer join to keep all variables)
combined_results <- merge(results1, results2, by = "Variable", all = TRUE)

combined_results %>%
  gt() %>%
  fmt_number(columns = c(P_Value_Model1, P_Value_Model2), decimals = 3)
```
After fitting model 








```{r}
#| label: Devariance_Comparation
#| tbl-cap: Devariance Comparation.
dev_model1 <- deviance(model1)  # Residual deviance of model1
dev_model2 <- deviance(model2)  # Residual deviance of model2

cat("Deviance of Model 1:", dev_model1, "\n")
cat("Deviance of Model 2:", dev_model2, "\n")
```






```{r}
#| label: AIC_BIC
#| tbl-cap: AIC & BIC of two models.
model_comparison <- bind_rows(
  glance(model1) %>% mutate(Model = "model1"),
  glance(model2) %>% mutate(Model = "model2")
) %>% 
  dplyr::select(Model, AIC, BIC)
kable(model_comparison, digits = 2, caption = "Model comparison values for different models")# Print the table with kable
```

### Odds

We can obtain the odds scale $\frac{p}{1-p}$ by

$$
\frac{p}{1-p}= exp(`r mod2coefs[1]` + `r mod2coefs[2]` \cdot \textrm{crl.tot} +`r mod2coefs[3]` \cdot \textrm{dollar} +`r mod2coefs[4]` \cdot \textrm{bang} +`r mod2coefs[5]` \cdot \textrm{money} +`r mod2coefs[6]`\cdot \textrm{n000})
$$

```{r}
#| label: Getting odds scale.
model2 %>%
 coef() %>%
  exp() %>%
  t()%>%
  as.data.frame() %>%
  gt()
  
```

```{r}
#| label: fig-CI-of-odds-scale
#| fig-cap: 95% CI of confidents in odds.
plot_model(model2, show.values = TRUE,
           title = "Odds (Email indicator)", show.p = FALSE)
```

### Probabilities

We can obtain the probability $p=\text{Prob}(\text{spam})$ by $$
p=\frac{exp(`r mod2coefs[1]` + `r mod2coefs[2]` \cdot \textrm{crl.tot} +`r mod2coefs[3]` \cdot \textrm{dollar} +`r mod2coefs[4]` \cdot \textrm{bang} +`r mod2coefs[5]` \cdot \textrm{money} +`r mod2coefs[6]`\cdot \textrm{n000})}{1+exp(`r mod2coefs[1]` + `r mod2coefs[2]` \cdot \textrm{crl.tot} +`r mod2coefs[3]` \cdot \textrm{dollar} +`r mod2coefs[4]` \cdot \textrm{bang} +`r mod2coefs[5]` \cdot \textrm{money} +`r mod2coefs[6]`\cdot \textrm{n000})}
$$

## Conclusion
